require 'find'
require 'fileutils'
require 'yaml'
require 'ostruct'

class MiqCollectFiles

  attr_writer :verbose

  def initialize(collectionSpec)
    @csa = collectionSpec
    @csa = YAML.load_file(collectionSpec) if @csa.kind_of? String
    @csa = [@csa] if @csa.kind_of? Hash
    raise "Invalid collection spec" if !@csa.kind_of? Array
    @verbose = false
  end

  def collect
    @csa.each { |cs| doCollect(OpenStruct.new(cs)) }
  end

  def dumpSpec(specFile)
    YAML.dump(@csa, File.open(specFile, "w"))
  end

private

  def doCollect(cs)
    pwd = Dir.pwd

    #
    # The directory where the collection will be created.
    #
    destDir = File.join(pwd, cs.todir)
    makePath(destDir) unless File.exists? destDir

    #
    # The directory relative to which the files will be collected.
    #
    Dir.chdir(cs.basedir)
    puts "BASEDIR: #{Dir.pwd}" if @verbose

    cs.include.concat(cs.include_always).uniq! if cs.include && cs.include_always

    #
    # Loop through the files and directories that are to be included in the collection.
    #
    cs.include.each do |i|
      # collect_files.yaml, generated by svn diffs, can contain file paths the have been URL encoded, so decode them if the file doesn't exist
      # - .../vendor/gems/railties-3.2.8/.../%25file_name%25_generator.rb.tt
      unless File.exists? i
        require 'uri'
        i = URI.decode(i)
      end

      raise "File: #{i} does not exist" unless File.exists? i

      #
      # If this is a plain file, then include it in the collection.
      #
      if !File.directory? i
        #
        # Skip files that match an exclude RE.
        #
        next if cs.exclude && cs.exclude.detect { |e| i =~ e }

        puts "FILE: #{i}" if @verbose
        toFile = File.join(destDir, i)
        makePath(File.dirname(toFile))
        #
        # If the file path matches an encrypt RE and doesn't
        # match a noencrypt RE, then encrypt the contents of
        # the file before copying it to the collection.
        #
        if cs.encrypt && cs.encrypt.detect { |e| i =~ e }
          if !cs.noencrypt || !cs.noencrypt.detect { |ne| i =~ ne }
            encryptFile(i, toFile)
            next
          end
        end
        copyFile(i, toFile)
        next
      end

      #
      # If this is a directory, then recursively copy its contents
      # to the collection directory.
      #
      puts "DIR: #{i}" if @verbose
      Find.find(i) do |path|
        #
        # Prune directories that match an exclude RE.
        #
        if File.directory? path
          if cs.exclude && cs.exclude.detect { |e| path =~ e }
            Find.prune
            next
          end
          makePath(path)
          next
        end
        #
        # Skip files that match an exclude RE.
        #
        next if cs.exclude && cs.exclude.detect { |e| path =~ e }
        toFile = File.join(destDir, path)
        makePath(File.dirname(toFile))
        #
        # If the file path matches an encritp RE and doesn't
        # match a noencrypt RE, then encrypt the contents of
        # the file before copying it to the collection.
        #
        if cs.encrypt && cs.encrypt.detect { |e| path =~ e }
          if !cs.noencrypt || !cs.noencrypt.detect { |ne| path =~ ne }
            encryptFile(path, toFile)
            next
          end
        end
        copyFile(path, toFile)
      end
    end if cs.include

    Dir.chdir(pwd)
  end

  def makePath(path)
    return if File.exists? path
    parentDir = File.dirname(path)
    makePath(parentDir) if !File.exists? parentDir
    Dir.mkdir(path)
  end

  def copyFile(src, dest)
    puts "\t   COPY: #{src}\n\t     TO: #{dest}\n\n" if @verbose
    FileUtils.copy(src, dest)
  end
  alias_method :encryptFile, :copyFile
end # class MiqCollectFiles
